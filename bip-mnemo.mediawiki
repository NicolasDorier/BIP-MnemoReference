BIP: xxxx
Title: Mnemonic code for referencing transaction output in the blockchain
Authors: Nicolas Dorier, jl2012
Status: Draft
Type: Standards Track
Created: 2015

==Abstract==

This BIP describes the implementation of a mnemonic code for referencing any transaction output in the blockchain.

==Motivation==

==Generating the mnemonic address==

Definitions:

blockHeight: the height of the referenced block. Genesis block is 0
blockHash: the hash of the referenced block
txIndex: index of the referenced transaction in the block. Index of the first transaction in a block is 0
outputIndex: index of the referenced output in the transaction. Index of the first output in a transaction is 0
scriptPubKey: the scriptPubKey of the referenced output
c: a fixed integer, the minimal number of bits for checksum (to be defined later)
ymin = ceiling(log(txIndex + 1, 2))
zmin = ceiling(log(outputIndex + 1, 2))

Step1: Determine the number of bits and encoding of blockHeight
blockHeight takes x bits and is encoded as follow:

    For height =< 1,048,575 (0-1111-1111-1111-1111-1111), blockHeight is the height as 21bit interger
    For 1,048,575 < height =< 8,388,607, blockHeight is Concat(1, height as 23 bit integer), which totally takes 24bit. For example, block 1234567 is 1001-0010-1101-0110-1000-0111
    For height > 8,388,607, it is undefined and returns error

Step2: Determine the lower bound of words required for the mnemonic address

    w = ceiling((x + ymin + zmin + c + 1)/11)

Step3: Determine the number of bits for txIndex
txIndex takes y bits:

    y1 = ceiling(log(total number of transactions in the block, 2))
    y2 = 11w-1-x-c
    y = min(y1, y2)
    If (ymin > y), increase w by 1 and go back to Step 3 (This condition is not possible as the initial value of w must provide enough space for ymin)

Step4: Determine the number of bits for outputIndex
outputIndex takes z bits:

    z1 = ceiling(log(total number of output in the transaction, 2))
    z2 = 11w-1-x-y-c
    z = min(z1, z2)
    If (zmin > z), increase w by 1 and go back to Step 3

Step5: Calculate the checksum (little endian)

    checksum = SHA256(SHA256(blockHash|txIndex|outputIndex|scriptPubKey))
    cs = 11w-1-x-y-z

Step6: Get the rawAddress, encoded by using the number of bits calculated previously  

    rawAddress = Encode(blockHeight,x)|Encode(txIndex,y)|Encode(outputIndex,z)|Encode(checksum,cs)

Step7: Get the encryptionKey,  the least significant c bits of rawAddress

    encryptionKey = Substring(rawAddress, from:rawAddress.Length-c, count:c)

Step8: Get the encryptedAddress,

    encryptedAddress = XOR(Substring(rawAddress,from:0, count:rawAddress.Length-c),encryptionKey)

Step9: Get the finalAddress,

    finalAddress = encryptedAddress|encryptionKey|0

The last 0 denotes the address version

Step10: Convert finalAddress into mnemonic code following BIP-0039

==Decoding the mnemonic address==

Step1: Determine w = number of words in the mnemonic code

Step2: Convert mnemonic code into finalAddress following BIP-0039

Step3: Check is the last bit of finalAddress is 0, if not, returns an error

Step4: Get the encryptionKey

    encryptionKey = Substring(finalAddress,from:finalAddress.Length-1-c, count:c)

Step5: Get the rawAddress

    rawAddress = XOR(Substring(finalAddress,from: 0, to: finalAddress.Length - 1 - c) ,encryptionKey)

Step6: Determine the blockHeight

    If the first bit of rawAddress is 0, take the first 21 bit out of rawAddress. This is the blockHeight
    If the first bit of rawAddress is 1, drop it. Take the first 23 bit out of rawAddress. This is the blockHeight
    If the block does not exist, return error

Step7: Determine the txIndex

    Look up the blockchain for the referenced block and determine the total number of transactions in the block
    y1 = ceiling(log(total number of transactions in the block, 2))
    y2 = 11w-1-x-c
    y = min(y1, y2))
    txIndex = ToInt(Substring(rawAddress,from:x,count:y))
    If the transaction does not exist, return error

Step8: Determine the outputIndex

    Look up the referenced transaction and determine the total number of outputs in the transaction
    z1 = ceiling(log(total number of outputs in the transaction, 2))
    z2 = 11w-1-x-y-c
    z = min(z1, z2)
    outputIndex = ToInt(Substring(rawAddress, from:x+y,count:z))
    If the output does not exist, return error

Step9: Calculate the checksum

    Determine the blockHash and scriptPubKey
    checksum = SHA256(SHA256(Concat(blockHash-txIndex-outputIndex-scriptPubKey))) (all in little endian)
    cs = rawAddress.Length - x - y - z;
    valid = Substring(checksum,from:0,count:cs) == Substring(rawAddress,from:x + y + z, count:cs)
    If valid, the address is successfully resolved. Otherwise, return error.

==SPV client compatibility==

==Test vectors==